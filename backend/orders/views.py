import csv

from django.utils import timezone
from django.shortcuts import get_object_or_404
from django.utils.encoding import smart_str
from django.http import HttpResponse
from rest_framework.generics import ListAPIView
from rest_framework.decorators import action
from rest_framework.permissions import AllowAny, IsAdminUser, IsAuthenticated
from rest_framework.renderers import BrowsableAPIRenderer, JSONRenderer
from rest_framework.response import Response
from rest_framework.views import APIView
from rest_framework.filters import OrderingFilter, SearchFilter
from django_filters import rest_framework as filters
from mixins.bulk_delete_mixin import ListDestroyMixin
from db_analytics.services import FacebookConversionServices
from orders.models import Order, OrderProduct, OrderItem, Inventory
from orders.permissions import IsAdminOrUser, \
    Dear_Brightly_API_Key_Auth, \
    IsCustomerUpdatingOrCreatingOrder, \
    IsAdminOrUserWithUserUuidCheck, \
    IsAdminOrDearBrightlyAPIKey
from orders.serializers import OrderSerializer, InventorySerializer, OrderItemSerializer
from orders.services.services import OrderService
from dearbrightly.pagination import CustomPagination
from rest_framework.exceptions import APIException, ValidationError
from orders.filters import OrderFilter
from rest_framework import mixins, status, viewsets
from django.db.models import Q
from orders.services.supply_chain_services import SupplyChainService
from emr_new.services.curexa_service import CurexaService as NewCurexaService

import logging
logging.basicConfig()
logging.getLogger().setLevel(logging.DEBUG)
logger = logging.getLogger(__name__)


class OrderViewSet(mixins.CreateModelMixin,
                   mixins.RetrieveModelMixin,
                   mixins.UpdateModelMixin,
                   mixins.ListModelMixin,
                   viewsets.GenericViewSet
                   ):

    serializer_class = OrderSerializer
    lookup_field = 'uuid'
    bulk_model = Order
    pagination_class = CustomPagination

    def get_permissions(self):
        if self.action == 'update_pending_or_create':
            permission_classes = [IsCustomerUpdatingOrCreatingOrder]
        else: #['create', 'update', 'partial_update', 'retrieve', 'list']:
            permission_classes = [IsAdminOrUser]
        return [permission() for permission in permission_classes]

    def get_queryset(self):
        user = self.request.user
        qs = Order.objects.none()
        status = self.request.query_params.get('status', None)

        object_uuid = self.kwargs.get('uuid', None)

        if object_uuid:
            return Order.objects.filter(uuid=object_uuid)

        if user and user.is_superuser:
            qs = Order.objects.all().order_by('-created_datetime')

        if user and not user.is_superuser:
            qs = user.orders.all().order_by('-created_datetime')

        if status == 'pending_checkout':
            qs = qs.filter(
                Q(autogenerated=False) & (
                        Q(status=Order.Status.account_created) |
                        Q(status=Order.Status.pending_questionnaire) |
                        Q(status=Order.Status.pending_photos) |
                        Q(status=Order.Status.skin_profile_complete) |
                        Q(status=Order.Status.payment_failure) |
                        Q(status=Order.Status.pending_payment)))

        if status == 'fulfilled':
            qs = qs.filter(Q(status=Order.Status.shipped) |
                           Q(status=Order.Status.refunded) |
                           Q(status=Order.Status.cancelled))

        logger.debug(f'[Order][get_queryset] qs: {qs}')
        return qs

    def retrieve(self, request, pk=None):
        queryset = self.get_queryset()
        order = get_object_or_404(queryset, pk=pk)
        serializer = OrderSerializer(order)
        return Response(serializer.data)

    def partial_update(self, request, *args, **kwargs):
        response_with_updated_instance = super(OrderViewSet, self).partial_update(request, *args, **kwargs)
        order_products = request.data.pop('order_products') if request.data.get('order_products') else None
        order = self.get_object()
        updated_order = None
        if order_products:
            updated_order = OrderService().update_order_products(order_products, order)
            serializer = OrderSerializer(updated_order)
            return Response(serializer.data)

        logger.debug(f'[Orders Views][partial_update]'
                     f' Request: {request.data}.'
                     f' Order: {order}.'
                     f' Updated Order: {updated_order}.'
                     f' Order products: {order_products}.')

        return response_with_updated_instance

    @action(detail=False, methods=['post'])
    def update_pending_or_create(self, request):
        try:
            order, created = OrderService().update_pending_or_create(request)
            status_code = status.HTTP_201_CREATED if created else status.HTTP_200_OK
            if created:
               FacebookConversionServices().track_initiate_checkout(request, request.user, order)
            return Response(data=OrderSerializer(order).data,
                            status=status_code)
        except AttributeError as error:
            logger.error(f'[update_pending_or_create] Attribute error: {error}')
            return Response(data={'detail': 'User is unauthorized'},
                            status=status.HTTP_401_UNAUTHORIZED)
        except ValidationError as error:
            return Response(data={'detail': error.detail},
                            status=status.HTTP_400_BAD_REQUEST)
        except APIException as error:
            return Response(data={'detail': error.detail},
                            status=status.HTTP_400_BAD_REQUEST)

    @action(detail=True, methods=['post'])
    def remove_discount(self, request, uuid):
        try:
            order = get_object_or_404(Order, uuid=uuid)
            order.discount_code = None
            order.discount = 0
            order.save()
            order.update_order_item_discount()

            return Response(data=OrderSerializer(order).data,
                            status=status.HTTP_200_OK)
        except APIException as error:
            return Response(data={'detail': error.detail},
                            status=status.HTTP_400_BAD_REQUEST)

# TODO - save in const file on client side
class OrderStatusChoicesView(APIView):
    permission_classes = (IsAuthenticated,)
    renderer_classes = (JSONRenderer, BrowsableAPIRenderer,)

    def get(self, request):
        return Response(data=Order.Status.values)

class UserOrderListView(ListAPIView):
    serializer_class = OrderSerializer
    lookup_field = 'uuid'
    permission_classes = (IsAdminOrUserWithUserUuidCheck, )
    filter_backends = (filters.DjangoFilterBackend, SearchFilter, OrderingFilter)
    ordering = ['-purchased_datetime', '-created_datetime']
    filter_class = OrderFilter

    def get_queryset(self):
        user_uuid = self.kwargs['user_uuid']
        return Order.objects.all().filter(Q(customer__uuid=user_uuid) &
                                          ~Q(status=Order.Status.account_created) &
                                          Q(purchased_datetime__isnull=False)).order_by('-id')

class AdminInventoryViewSet(viewsets.ModelViewSet):
    queryset = Inventory.objects.all()
    serializer_class = InventorySerializer
    lookup_field = 'id'
    permission_classes = (Dear_Brightly_API_Key_Auth, )

    @action(detail=False, methods=['post'], url_path='update_inventories')
    def update_inventories(self, request):
        try:
            inventories = request.data
            for inv in inventories:

                serializer = InventorySerializer(data=inv)
                serializer.is_valid(raise_exception=True)

                old_inventory = get_object_or_404(Inventory, id=inv.get('id', None))
                old_inventory.quantity = inv.get('quantity', 0)
                old_inventory.starting_order_number = inv.get('starting_order_number', None)
                old_inventory.bottle_type = inv.get('bottle_type', None)
                old_inventory.description = inv.get('description', None)
                old_inventory.name = inv.get('name', None)
                old_inventory.quantity_remaining_notification = inv.get('quantity_remaining_notification', 0)
                old_inventory.save()
            return Response(data={}, status=status.HTTP_200_OK)
        except (ValidationError, APIException) as error:
            return Response(data={'detail': error.detail}, status=status.HTTP_400_BAD_REQUEST)

class AdminOrderItemViewSet(viewsets.ModelViewSet):
    serializer_class = OrderItemSerializer
    permission_classes = (Dear_Brightly_API_Key_Auth, )
    def get_queryset(self):
        order_number = self.request.GET.get('order_number', 0)
        return OrderItem.objects.filter(Q(order__id=order_number))

    # update bottle type
    @action(detail=False, methods=['post'], url_path='update_order_item')
    def update_order_item(self, request):
        from orders.models import Order

        try:
            payload = request.data
            
            order_item = get_object_or_404(OrderItem, id=payload.get('id', None))
            order_item.bottle_type = payload.get('bottle_type', None)
            order_item.save()

            order = order_item.order
            if int(order.status) == Order.Status.pending_pharmacy:
                curexa_response = NewCurexaService().create_curexa_order(order)
                return curexa_response

            return Response(data={}, status=status.HTTP_200_OK)
        except (ValidationError, APIException) as error:
            logger.error(f'[AdminOrderItemViewSet][update_order_item] Error: {error}')
            return Response(data={}, status=status.HTTP_400_BAD_REQUEST)

class AdminOrderViewSet(viewsets.ModelViewSet, ListDestroyMixin):
    serializer_class = OrderSerializer
    filter_backends = (filters.DjangoFilterBackend, SearchFilter, OrderingFilter)
    lookup_field = 'uuid'
    bulk_model = Order
    pagination_class = CustomPagination
    ordering = ['-purchased_datetime', '-created_datetime', 'id']
    search_fields = ('$customer__email', '$customer__first_name', '$customer__last_name',
                     '$discount_code', '=id', '$notes', 'purchased_datetime', '=status',)
    filter_class = OrderFilter


    def get_permissions(self):
        if self.action in ['create', 'list', 'partial_update', 'retrieve', 'update']:
            permission_classes = [IsAdminOrDearBrightlyAPIKey]
        else: # destroy, bulk_destroy, send_user_reminder_emails, etc.
            permission_classes = [Dear_Brightly_API_Key_Auth]
        return [permission() for permission in permission_classes]

    def get_queryset(self):
        user = self.request.user
        qs = Order.objects.all().order_by('-id')
        if user.is_superuser:
            qs = qs.filter(purchased_datetime__isnull=False).order_by('-id')
        return qs

    def retrieve(self, request, uuid=None):
        queryset = self.get_queryset()
        order = get_object_or_404(queryset, uuid=uuid)
        order.seen_datetime = timezone.now()
        order.save(update_fields=['seen_datetime'])
        serializer = OrderSerializer(order)
        return Response(serializer.data, status=status.HTTP_200_OK)

    def list(self, request, pk=None):
        export = self.request.query_params.get('export', None)

        logger.debug(f'[AdminOrderViewSet][list] Request: {request.data}')

        if pk == None:
            orders_queryset = self.get_queryset()
        else:
            orders_queryset = self.get_queryset.filter(id=pk)

        filtered_orders_queryset = self.filter_queryset(orders_queryset)

        if export:
            return self._export(filtered_orders_queryset)

        page = self.paginate_queryset(filtered_orders_queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(filtered_orders_queryset, many=True)
        return Response(serializer.data)

    @action(detail=False, methods=['post'], url_path='send_user_reminder_emails')
    def send_user_reminder_emails(self, request):
        from orders.services.services import OrderService

        OrderService().send_user_reminder_emails()

        return Response(status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'])
    def bulk_update_status(self, request):
        order_uuids = request.data.get('order_uuids')
        order_status = request.data.get('status')
        updated_orders = Order.objects.filter(uuid__in=order_uuids).update(status=order_status)
        logger.debug(f'[bulk_update_status] Request: {request}. Order UUIDs: {order_uuids}. '
                     f'Status: {order_status}. Updated orders: {updated_orders}')
        return Response(status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'])
    def delete_unpurchased_orders(self, request):
        OrderService().delete_unpurchased_orders()
        return Response(status=status.HTTP_200_OK)

    def _export(self, queryset):
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename=orders.csv'
        writer = csv.writer(response, csv.excel)
        response.write(u'\ufeff'.encode('utf8'))
        writer.writerow([
            smart_str(u'ID'),
            smart_str(u'Purchase Date'),
            smart_str(u'Customer Email'),
            smart_str(u'Customer First Name'),
            smart_str(u'Customer Last Name'),
            smart_str(u'Products'),
            smart_str(u'Is Refill'),
            smart_str(u'Total'),
            smart_str(u'Tax'),
            smart_str(u'Shipping Fee'),
            smart_str(u'Discount'),
            smart_str(u'Discount Code'),
            smart_str(u'Medical Visit ID'),
            smart_str(u'Date of Birth'),
            smart_str(u'State'),
        ])
        for obj in queryset:
            medical_visit = obj.emr_medical_visit.id if obj.emr_medical_visit else ''
            writer.writerow([
                smart_str(obj.order_number),
                smart_str(obj.purchased_datetime),
                smart_str(obj.customer.email),
                smart_str(obj.customer.first_name),
                smart_str(obj.customer.last_name),
                smart_str(obj.get_products_list()),
                smart_str(obj.is_refill),
                smart_str(obj.total_amount),
                smart_str(obj.tax),
                smart_str(obj.shipping_fee),
                smart_str(obj.discount),
                smart_str(obj.discount_code),
                smart_str(medical_visit),
                smart_str(obj.customer.dob),
                smart_str(obj.shipping_details.state)
            ])
        return response

    @action(detail=False, methods=['post'])
    def verify_order_total_amount(self, request):
        for order in Order.objects.filter(Q(purchased_datetime__isnull=False)):
            total_amount = 0
            for order_item in order.order_items.all():
                total_amount += order_item.price

                logger.debug(f'[verify_order_total_amount] '
                             f'Order: {order.id}. '
                             f'Order Item: {order_item.id}. '
                             f'Total amount: {total_amount}.')

            if total_amount != order.subtotal:
                logger.debug(f'[verify_order_total_amount] '
                             f'!!!!!!!!!!!!! Order product total does not match order subtotal. '
                             f'Order: {order.id}. '
                             f'Order Subtotal: {order.subtotal}. '
                             f'Total amount: {total_amount}.')
            else:
                logger.debug(f'[verify_order_total_amount] '
                             f'************ Order product total matches order subtotal. '
                             f'Order: {order.id}. '
                             f'Order Subtotal: {order.subtotal}. '
                             f'Total amount: {total_amount}.')

        return Response(status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'])
    def patch_migrated_orders_tax_rate(self, request):
        for order in Order.objects.filter(Q(purchased_datetime__isnull=False)):
            if not order.is_migrated_order():
                continue

            for order_item in order.order_items.all():
                ratio = order_item.price / order.subtotal
                order_item.tax = ratio * order.tax
                order_item.tax_rate = round((order.tax/(order.subtotal-order.discount)), 4)
                order_item.save()

                logger.debug(f'[patch_migrated_orders_tax_rate] '
                             f'Order: {order.id}. '
                             f'Order Item: {order_item.id}. '
                             f'Order Item Tax: {order_item.tax}. '
                             f'Order Item Tax Rate: {order_item.tax_rate}')

        return Response(status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'])
    def patch_order_item_discounts(self, request):
        from orders.services.services import OrderService

        for order in Order.objects.all():
            if order.discount > 0:
                order.update_order_item_discount()

        return Response(status=status.HTTP_200_OK)

    @action(detail=True, methods=['post'])
    def patch_curexa_order_creation(self, request, uuid=None):
        order = get_object_or_404(Order, uuid=uuid)
        prescription_data = request.data.get('prescription_data')

        NewCurexaService().create_curexa_order(order=order, prescription_data=prescription_data)

        return Response(status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'])
    def delete_empty_orders(self, request):
        from orders.services.services import OrderService

        OrderService().delete_empty_orders()

        return Response(status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'])
    def delete_payment_uncaptured_autogenerated_orders(self, request):
        from orders.services.services import OrderService

        OrderService().delete_payment_uncaptured_autogenerated_orders()

        return Response(status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'])
    def patch_bottle_types(self, request):
        from emr.models import Prescription

        start_order_id = int(request.data.get('start_order_id'))
        prescription_id = int(request.data.get('prescription_id'))
        bottle_type = request.data.get('bottle_type')

        prescription = get_object_or_404(Prescription, id=prescription_id)

        for order in Order.objects.filter(Q(id__gt=start_order_id) &
                                          Q(patient_prescription__prescription=prescription)):
            rx_order_items = order.order_items.filter(Q(product_id=9) | Q(product_id=11))
            for rx_order_item in rx_order_items:
                if rx_order_item.bottle_type != bottle_type:
                    rx_order_item.bottle_type = bottle_type
                    rx_order_item.save()
                    logger.debug(f'[patch_bottle_types] Updating order {order.id} to {bottle_type}. '
                                 f'Prescription: {order.patient_prescription.prescription.display_name}. '
                                 f'Prescription ID: {order.patient_prescription.prescription.id}. '
                                 f'rx_order_item: {rx_order_item}.')

        return Response(status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'])
    def capture_payment(self, request):
        from payment_new.services.payment_service import PaymentService as NewPaymentService

        order_id = request.data.get('order_id')
        order = get_object_or_404(Order, id=order_id)

        NewPaymentService().capture_payment(order=order)

        return Response(status=status.HTTP_200_OK)

    @action(detail=False, methods=['post'])
    def submit_order_smart_warehouse(self, request):
        order_id = request.data.get("order_id")
        order = get_object_or_404(Order, id=order_id)

        if int(order.status) == Order.Status.pending_pharmacy:
            response = NewCurexaService().create_curexa_order(order,
                                                           prescription_data=None,
                                                           include_otc_products=False)
            if response.status_code == status.HTTP_200_OK:
                return SupplyChainService().submit_order_smart_warehouse(order=order)
            return response
        else:
            return SupplyChainService().submit_order_smart_warehouse(order=order)

    @action(detail=False, methods=['post'])
    def update_tracking_info_smart_warehouse(self, request):
        days_before_today = request.data.get('days_before_today')
        return SupplyChainService().update_tracking_info(days_before_today)

    @action(detail=False, methods=['get'])
    def get_inventory_data_smart_warehouse(self, request):
        state = request.GET.get('state', '')
        return SupplyChainService().get_inventory_data(state)
